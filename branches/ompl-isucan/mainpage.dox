/**
\mainpage

@section summary Summary 
    
   @b ompl (Open Motion Planning Library) consists of a set of
   sampling-based motion planning algorithms and nothing more. There
   is no environment specification, there is no collision detection or
   visualisation. There are only motion planners. The purpose of this
   library is to be extensible and freely available. It currently
   contains a set of geometric sampling-based motion planners and some
   initial versions of planners that can account for differential
   constraints.

   The overall structure can be observed by looking at the @b base/
   directory. There are four main components: 
   - the state manifold (ompl::base::StateManifold) we are planning in, and a control manifold (ompl::control::ControlManifold), if planning with controls
   - the space information (ompl::base::SpaceInformation), which is constructed from the state manifold (and the control manifold, if planning with controls - ompl::control::SpaceInformation)
   - the problem definition (ompl::base::ProblemDefinition)
   - the planner (ompl::base::Planner)


   <hr> 

   The code in this library is meant to be thread safe. All static,
   non-member or const member functions are thread safe. Calling
   member functions that are not const in multiple threads
   simultaneously is unsafe and locks should be used.
   
   <hr>

   @section avail_planners Available Planners
   
   @subsection geometric_planners Planning under geometric constraints

   This set of planners only accounts for the geometric constraints of
   the system.  Infinite accelerations and velocities are assumed.


   - @ref gRRT "Rapidly-exploring Random Trees (RRT)"
   - @ref gLazyRRT "Lazy RRT (LazyRRT)"
   - @ref gRRTC "RRT Connect (RRTConnect)"
   - @ref gpRRT "Parallel Rapidly-exploring Random Trees (pRRT)"
   - @ref gSBL "Single-query Bi-directional Lazy collision checking planner (SBL)"
   - @ref gpSBL "Parallel Single-query Bi-directional Lazy collision checking planner (pSBL)"
   - @ref gEST "Expansive Space Trees (EST)"
   - @ref gKPIECE1 "Geometric Planning by Interior-Exterior Cell Exploration (KPIECE)"
   - @ref gLBKPIECE1 "Lazy Bi-directional KPIECE (LBKPIECE)"	

   Other tools:

   - @ref HCIK "Inverse Kinematics with Hill Climbing"
   - @ref GAIK "Inverse Kinematics with Genetic Algorithms"

   @subsection kusage Usage

   @subsubsection plannerinstance Instantiating a planner

   In order to use a motion planner (ompl::geometric::XXX, from @b
   ompl/geometric/planners), an instance of
   ompl::base::SpaceInformation must be available. This instance is
   supplied to the planner's constructor.  After creation, a call to
   the planner's @b setup() method must be made and the planner
   instance is ready for use: the @b solve() method can be called
   repeatedly with different allowed time durations until a solution
   is found.

   @subsubsection spaceinfo Instantiating a space information class

   Creating an actual instance of a space information class
   (ompl::base::SpaceInformation) is trivial as the constructor
   requires only a state manifold to be specified. However, this class
   needs to be configured before use:

     - ompl::base::StateValidityChecker is an abstract class that
       provides functionality for determining whether a state is valid
       or not. This class is assumed to be thread safe. The user must
       provide an implementation of this class and supply it to the
       space information instance by calling
       ompl::base::SpaceInformation::setStateValidityChecker().

     - a call needs to be made to
       ompl::base::SpaceInformation::setStateValidityCheckingResolution()
       in order to specify the maximu distance between states to be
       checked for validity along a path segment. If this call is not
       made, the extents of the space are estimated and this distance
       is computed. This functionality however is NOT SAFE. It is
       meant to be used as last resort, as this parameter needs to be
       specified for planning to work.

   Once the class is instantiated and all parameters have been set,
   the ompl::base::SpaceInformation::setup() function needs to be
   called and the instance is ready for use.

   @subsubsection manifold Instantiating a state manifold

   Simply create an instance of a class that iherits from
   ompl::base::StateManifold. To change the definition of the employed
   sampler or distance function, it is possible to provide a further
   specialization of such a manifold. See @ref implementStateManifold

   @subsubsection pdef Instantiating a problem definition

     - instances of ompl::base::State or ompl::base::ScopedState need
       to be supplied as starting states for the system (at least
       one), using ompl::base::ProblemDefinition::addStartState().

     - an ompl::base::Goal specification must be set using
       ompl::base::ProblemDefinition::setGoal(). For simplicity,
       specifications of this class are available:
       ompl::base::GoalRegion, ompl::base::GoalSampleableRegion,
       ompl::base::GoalState, ompl::base::GoalStates.
       

   @subsubsection kinstexample Example

   @code

   #include <ompl/base/SpaceInformation.h>
   #include <ompl/geometric/planners/rrt/RRT.h>
   #include <ompl/base/GoalState.h>
   #include <ompl/base/manifolds/RealVectorStateManifold.h>

   #include <ompl/geometric/PathSimplifier.h>

   ...

   class myStateValidityChecker : public ompl::base::StateValidityChecker
   {
   public:
      myStateValidityChecker(const ompl::base::SpaceInformation *si) : ompl::base::StateValidityChecker(si)
      {
      }
      
      virtual bool isValid(const ompl::base::State *state) const
      {
            // provide implementation here
      }
   };

   ...

   ompl::base::StateManifoldPtr manifold(new ompl::base::RealVectorStateManifold(2));
   // set bounds for manifold 

   ompl::base::SpaceInformationPtr si(new ompl::base::SpaceInformation(manifold));
   
   ompl::base::ProblemDefinitionPtr pdef(new ompl::base::ProblemDefinition(si));

   ompl::base::ScopedState<ompl::base::RealVectorStateManifold::StateType> start;
   // fill start state

   pdef->addStartState(start); 

   ompl::base::GoalPtr gs(new ompl::base::GoalState(si));
   // fill goal

   pdef->setGoal(gs);

   ompl::base::StateValidityCheckerPtr svc(new myStateValidityChecker(si));
   si->setStateValidityChecker(svc);

   si->setup();

   ompl::base::PlannerPtr p(new ompl::geometric::RRT(si));
   p->setup();

   p->setProblemDefinition(pdef);
   p->solve(0.5);
   
   ompl::geometric::PathGeometric *solution = static_cast<ompl::geometric::PathGeometric*>(si->getGoal()->getSolutionPath().get());
   

   // create an instance if a geometric smoother 
   ompl::geometric::PathSimplifierPtr sm(new ompl::geometric::PathSimplifier(si));
   sm->simplifyMax(*solution); // this is done in place
   
   // output solution somehow 
   ...

   // all memory automatically deleted by smart pointers

   @endcode

   @subsection dynamic_planners Planning under differential constraints

   This part of the library is not considered ready for use.
   
   - @ref cRRT "Rapidly-exploring Random Trees (RRT)"
   - @ref cKPIECE1 "Kinodynamic Planning by Interior-Exterior Cell Exploration (KPIECE)"

@section howto How To's

   @ref implementStateManifold How to implement a new state manifold

*/
