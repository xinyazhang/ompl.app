/**
\mainpage

@section summary Summary 
    
   @b ompl (Open Motion Planning Library) consists of a set of
   sampling-based motion planning algorithms and nothing more. There
   is no environment specification, there is no collision detection or
   visualisation. There are only motion planners. The purpose of this
   library is to be extensible and freely available. It currently
   contains a set of geometric sampling-based motion planners and some
   initial versions of planners that can account for differential
   constraints.

   The overall structure can be observed by looking at the @b base/
   directory. There are four main components: 
   - the state manifold (ompl::base::StateManifold) we are planning in, and a control manifold (ompl::control::ControlManifold), if planning with controls
   - the space information (ompl::base::SpaceInformation), which is contructed from the state manifold (and the control manifold, if planning with controls - ompl::control::SpaceInformation)
   - the problem definition (ompl::base::ProblemDefinition)
   - the planner (ompl::base::Planner)


   <hr> 

   The code in this library is meant to be thread safe. All static,
   non-member or const member functions are thread safe. Calling
   member functions that are not const in multiple threads
   simultaneously is unsafe and locks should be used.
   
   <hr>

   @section avail_planners Available Planners
   
   @subsection geometric_planners Planning under geometric constraints

   This set of planners only accounts for the geometric constraints of
   the system.  Infinite accelerations and velocities are assumed.


   - @ref gRRT "Rapidly-exploring Random Trees (RRT)"
   - @ref gLazyRRT "Lazy RRT (LazyRRT)"
   - @ref gRRTC "RRT Connect (RRTConnect)"
   - @ref gpRRT "Parallel Rapidly-exploring Random Trees (pRRT)"
   - @ref gSBL "Single-query Bi-directional Lazy collision checking planner (SBL)"
   - @ref gpSBL "Parallel Single-query Bi-directional Lazy collision checking planner (pSBL)"
   - @ref gEST "Expansive Space Trees (EST)"
   - @ref gKPIECE1 "Geometric Planning by Interior-Exterior Cell Exploration (KPIECE)"
   - @ref gLBKPIECE1 "Lazy Bi-directional KPIECE (LBKPIECE)"	

   Other tools:

   - @ref HCIK "Inverse Kinematics with Hill Climbing"
   - @ref GAIK "Inverse Kinematics with Genetic Algorithms"
   - @ref IKPlanner "Inverse Kinematics Planner"

   @subsection kusage Usage

   @subsubsection plannerinstance Instantiating a planner

   In order to use a motion planner (ompl::geometric::XXX, from @b
   ompl/geometric/planners), an instance of a geometric space
   information must be available. This instance is supplied to the
   planner's constructor.  After creation, a call to the planner's @b
   setup() method must be made and the planner instance is ready for
   use: the @b solve() method can be called repeatedly with different
   allowed time durations until a solution is found.

   @subsubsection spaceinfo Instantiating a space information class

   Creating an actual instance of a space information class
   (ompl::base::SpaceInformation) is trivial as the constructor
   requires only a state manifold to be specified. However, this class
   needs to be configured before use:

     - a std::vector < ompl::base::StateComponent > must be supplied to
       the space information class by calling @b
       setStateComponents. This specification describes a bounding
       box for the state space. Random samples will only be generated
       within this box.

     - instances of ompl::base::State need to be supplied as starting
       states for the system (at least one), using @b addStartState.

     - an ompl::base::Goal specification must be set using @b
       setGoal. For simplicity, specifications of this class are
       available: ompl::base::GoalRegion,
       ompl::base::GoalSampleableRegion, ompl::base::GoalState,
       ompl::base::GoalStates.

     - ompl::base::StateValidityChecker is an abstract class that
       provides functionality for determining whether a state is valid
       or not. This class is assumed to be thread safe. The user must
       provide an implementation of this class and supply it to the
       space information instance by calling @b
       setStateValidityChecker.
       
     - ompl::base::StateDistanceEvaluator is an abstract class that
       provides functionality for computing distances between
       functions. This class is assumed to be thread safe. The user
       can specify which implementation of this class is to be used by
       calling @b setStateDistanceEvaluator. If no distane evaluator
       is specified, the default
       ompl::base::L2SquareStateDistanceEvaluator is used (square of
       L2 norm).

     - ompl::base::StateSampler is an abstract class that provides
       functionality for sampling states. This class is NOT assumed to
       be thread safe because of issues of generating random samples
       in parallel, using the same seed. For this reason, state samplers are
       instantiated as needed. In order for proper instantiation to
       occur, the user should supply a boost::function that takes a
       const ompl::base::SpaceInformation as argument and returns an
       instance of the desired sampler (which inherits from
       ompl::base::StateSampler). This function can be supplied to the
       space information instance using @b
       setStateSamplerAllocator. If no state sampler allocator is
       specified, a default allocator that instantiates
       ompl::base::UniformStateSampler is assumed.

     - ompl::geometric::StateInterpolatorGeometric is an abstract
       class that provides functionality for interpolating between
       states. This class is assumed to be thread safe. Users can set
       which instance of this class to use by calling @b
       setStateInterpolator. If no state interpolator is provided, a
       linear one is assumed
       (ompl::geometric::LinearStateInterpolatorGeometric).


   Some of these parameters can als be set if the user provides a
   space information class that inherits from
   ompl::geometric::SpaceInformationGeometric. This use is encouraged
   if it simplifies the code.

   Once the class is instantiated and all parameters have been set,
   the @b setup() function needs to be called and the instance is
   ready for use.

   @subsubsection kinstexample Example

   @code

   #include <ompl/base/SpaceInformation.h>
   #include <ompl/geometric/planners/rrt/RRT.h>
   #include <ompl/base/GoalState.h>
   #include <ompl/base/manifolds/RealVectorStateManifold.h>

   #include <ompl/geometric/PathSimplifier.h>

   ...

   class myStateValidityChecker : public ompl::base::StateValidityChecker
   {
   public:
      myStateValidityChecker(const ompl::base::SpaceInformation *si) : ompl::base::StateValidityChecker(si)
      {
      }
      
      virtual bool isValid(const ompl::base::State *state) const
      {
            // provide implementation here
      }
   };

   ...

   ompl::base::StateManifoldPtr manifold(new ompl::base::RealVectorStateManifold(2));
   // set bounds for manifold 

   ompl::base::SpaceInformationPtr si(new ompl::base::SpaceInformation(manifold));
   
   ompl::base::ProblemDefinitionPtr pdef(new ompl::base::ProblemDefinition(si));

   ompl::base::ScopedState<ompl::base::RealVectorStateManifold::StateType> start;
   // fill start state

   pdef->addStartState(start); 

   ompl::base::GoalPtr gs(new ompl::base::GoalState(si));
   // fill goal

   pdef->setGoal(gs);

   ompl::base::StateValidityCheckerPtr svc(new myStateValidityChecker(si));
   si->setStateValidityChecker(svc);

   si->setup();

   ompl::base::PlannerPtr p(new ompl::geometric::RRT(si));
   p->setup();

   p->setProblemDefinition(pdef);
   p->solve(0.5);
   
   ompl::geometric::PathGeometric *solution = static_cast<ompl::geometric::PathGeometric*>(si->getGoal()->getSolutionPath().get());
   

   // create an instance if a geometric smoother 
   ompl::geometric::PathSimplifierPtr sm(new ompl::geometric::PathSimplifier(si));
   sm->simplifyMax(*solution); // this is done in place
   
   // output solution somehow 
   ...

   // all memory automatically deleted by smart pointers

   @endcode

   @subsection dynamic_planners Planning under differential constraints

   This part of the library is not considered ready for use.
   
   - @ref dRRT "Rapidly-exploring Random Trees (RRT)"

@section howto How To's

   @ref implementStateManifold How to implement a new state manifold

*/
