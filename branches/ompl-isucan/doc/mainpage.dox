/**
\mainpage

@section summary Summary 
    
   @b ompl (Open Motion Planning Library) consists of a set of
   sampling-based motion planning algorithms and nothing more. There
   is no environment specification, there is no collision detection or
   visualisation. There are only motion planners. The purpose of this
   library is to be easy to use, extensible and freely available.

   The overall structure can be observed by looking at the @b base/
   directory. There are four main components: 
   - the state manifold (ompl::base::StateManifold) we are planning in, and a control manifold (ompl::control::ControlManifold), if planning with controls
   - the space information (ompl::base::SpaceInformation), which is constructed from the state manifold (and the control manifold, if planning with controls - ompl::control::SpaceInformation)
   - the problem definition (ompl::base::ProblemDefinition)
   - the planner (ompl::base::Planner)


   <hr> 

   The code in this library is meant to be thread safe. All static,
   non-member or const member functions are thread safe. Calling
   member functions that are not const in multiple threads
   simultaneously is unsafe and locks should be used.
   
   <hr>

   @section avail_planners Available Planners
   
   @subsection geometric_planners Planning under geometric constraints

   This set of planners only accounts for the geometric constraints of
   the system.  Infinite accelerations and velocities are assumed.


   - @ref gRRT "Rapidly-exploring Random Trees (RRT)"
   - @ref gLazyRRT "Lazy RRT (LazyRRT)"
   - @ref gRRTC "RRT Connect (RRTConnect)"
   - @ref gpRRT "Parallel Rapidly-exploring Random Trees (pRRT)"
   - @ref gSBL "Single-query Bi-directional Lazy collision checking planner (SBL)"
   - @ref gpSBL "Parallel Single-query Bi-directional Lazy collision checking planner (pSBL)"
   - @ref gEST "Expansive Space Trees (EST)"
   - @ref gKPIECE1 "Geometric Planning by Interior-Exterior Cell Exploration (KPIECE)"
   - @ref gLBKPIECE1 "Lazy Bi-directional KPIECE (LBKPIECE)"	

   Other tools:

   - @ref HCIK "Inverse Kinematics with Hill Climbing"
   - @ref GAIK "Inverse Kinematics with Genetic Algorithms"

   @subsection dynamic_planners Planning under differential constraints
   
   - @ref cRRT "Rapidly-exploring Random Trees (RRT)"
   - @ref cKPIECE1 "Kinodynamic Planning by Interior-Exterior Cell Exploration (KPIECE)"


   @section gusage Usage

   @subsection plannerinstance Instantiating a planner

   \par
   In order to use a motion planner (ompl::geometric::XXX, from @b
   ompl/geometric/planners or ompl::control::XXX, from @b
   ompl/control/planners), an instance of ompl::base::SpaceInformation
   (ompl::control::SpaceInformation, respectively) must be
   available. This instance is supplied to the planner's constructor.
   After creation, a call to the planner's
   ompl::base::Planner::setup() method must be made and the planner
   instance is ready for use: the ompl::base::Planner::solve() method
   can be called repeatedly with different allowed time durations
   until a solution is found. A call to ompl::base::Planner::clear()
   will restore a planner to its state before any calls to the
   ompl::base::Planner::solve() method were made.
   @code
   using namespace ompl;
   base::SpaceInformationPtr si(...);
   base::PlannerPtr planner(new geometric::SBL(si));
   @endcode

   @subsection spaceinfo Instantiating a space information class

   \par
   Creating an actual instance of a space information class
   (ompl::base::SpaceInformation) is trivial as the constructor
   requires only a state manifold to be specified
   (ompl::base::StateManifold). When planning with controls
   (ompl::control::SpaceInformation), this constructor requires a
   control manifold (ompl::control::ControlManifold) as well.  The space information
   class also needs to be configured before use:\n\n
     - ompl::base::StateValidityChecker is an abstract class that
       provides functionality for determining whether a state is valid
       or not. This class is assumed to be thread safe. The user must
       provide an implementation of this class and supply it to the
       space information instance by calling
       ompl::base::SpaceInformation::setStateValidityChecker().
       Alternatively, the user can pass a function of the type
       ompl::base::StateValidityCheckerFn to
       ompl::base::SpaceInformation::setStateValidityChecker()
       instead.
     - a call needs to be made to
       ompl::base::SpaceInformation::setStateValidityCheckingResolution()
       in order to specify the maximum distance between states to be
       checked for validity along a path segment. If this call is not
       made, ompl::base::SpaceInformation::estimateMaxResolution() is
       used to determine this resolution. This functionality however
       is NOT SAFE. It is meant to be used as last resort, as this
       parameter usually needs to be specified for planning to work.
   @code
   // define this class:
   class myStateValidityCheckerClass : public base::StateValidityChecker
   {
   public:
	myStateValidityCheckerClass(const base::SpaceInformationPtr &si) :
	  base::StateValidityChecker(si)
   	{
	}
	
	virtual bool isValid(const base::State *state) const
	{
		return ...;
	}
   };
   // or this function:
   bool myStateValidityCheckerFunction(const base::State *state)
   {
	return ...;
   }	

   base::SpaceInformationPtr si(manifold);
   // either this call:
   si->setStateValidityChecker(base::StateValidityCheckerPtr(new myStateValidityCheckerClass(si)));
   // or this call:
   si->setStateValidityChecker(boost::bind(&myStateValidityCheckerFunction, _1));
   si->setStateValidityCheckingResolution(0.1);
   si->setup();
   @endcode

   \par
   Once the class is instantiated and all parameters have been set,
   the ompl::base::SpaceInformation::setup() function needs to be
   called and the instance is ready for use.

   @subsection smanifold Instantiating a state manifold

   \par
   Simply create an instance of a class that iherits from
   ompl::base::StateManifold. To change the definition of the employed
   sampler or distance function, it is possible to provide a further
   specialization of such a manifold. See @ref implementStateManifold.
   @code
   base::StateManifoldPtr manifold(new base::SE2StateManifold());
   // set bounds ....
   @endcode

   @subsection cmanifold Instantiating a control manifold

   \par
   Simply create an instance of a class that inherits from
   ompl::control::ControlManifold. Usually,
   ompl::control::RealVectorControlManifold is sufficient.
   An implementation needs to be specified for the ompl::control:ControlManifold::propagate() 
   either by inheriting from the manifold class or by making a call to
   ompl::control::ControlManifold::setPropagationFunction().
   @code
   base::StateManifoldPtr manifold(new base::SE2StateManifold());
   // set bounds for manifold
   control::ControlManifoldPtr cmanifold(new control::RealVectorControlManifold(manifold));
   // set bounds for cmanifold
   @endcode

   @subsection pdef Instantiating a problem definition

     - instances of ompl::base::State or ompl::base::ScopedState need
       to be supplied as starting states for the system (at least
       one), using ompl::base::ProblemDefinition::addStartState().

     - an ompl::base::Goal specification must be set using
       ompl::base::ProblemDefinition::setGoal(). For simplicity,
       the following specifications of this class are available:
       ompl::base::GoalRegion, ompl::base::GoalSampleableRegion,
       ompl::base::GoalState, ompl::base::GoalStates.
       
     - as a simplification, a call can be made to
       ompl::base::ProblemDefinition::setStartAndGoalStates(). This
       will clear previous settings, add one start state and create an
       ompl::base::GoalState representation for the goal.
   @code
   base::SpaceInformationPtr si(...);
   base::ProblemDefinifionPtr pdef(new base::ProblemDefinition(si));

   base::ScopedState start;
   // fill start state

   base::ScopedState goal;
   // fill goal state

   pdef->setStartAndGoalStates(start, goal);
   @endcode

   \par
   An important part of setting the problem definition is filling the
   content of start states (and goal states, if using a goal
   representation that requires states). Please see \ref stateOps.

   @subsection simplesetup Using SimpleSetup

   \par
   The instantiation of all the above classes is facilitated by the
   ompl::geometric::SimpleSetup class (ompl::control::SimpleSetup,
   respectively). Please see the documentation of these classes for
   more information.

@section demo Demos

   @subsection gplanRigidBody Geometric planning for a rigid body in 3D

   \li Using ompl::geometric::SimpleSetup :\n\n
   @dontinclude RigidBodyPlanning.cpp
   Assuming the following namespace definitions:
   @skip ompl::base
   @until ompl::geometric
   And a state validity checking function defined like this:
   @skipline isStateValid
   We first create an instance of the manifold we are planning in.
   @skip planWithSimpleSetup
   @until StateManifold
   We then set the bounds for the R<sup>3</sup> component of this manifold:
   @skip RealVectorBounds
   @until setBounds
   Create an instance of ompl::geometric::SimpleSetup. Instances of ompl::base::SpaceInformation,
   and ompl::base::ProblemDefinition are created internally.
   @skipline SimpleSetup
   Set the state validity checker
   @skipline setStateValidityChecker
   Create a random start state:
   @skip start(manifold)
   @until start.random
   And a random goal state:
   @skip goal(manifold)
   @until goal.random
   Set these states as start and goal for SimpleSetup.
   @skipline setStartAndGoalStates
   We can now try to solve the problem. This will also trigger a call to ompl::geometric::SimpleSetup::setup() and create a default instance of a planner,
   since we have not specified one. Furthermore, ompl::base::Planner::setup() is called, which in turn calls ompl::base::SpaceInformation::setup(). This chain
   of calls will lead to computation of runtime parameters such as the state validity checking resolution. This call returns a boolean flag indicating whether 
   a solution has been found within the specified amount of time (in seconds).
   @skipline bool solved
   If a solution has been found, we can optionally simplify it and the display it
   @skip solved
   @until }
   \n

   \li
   Without ompl::geometric::SimpleSetup :\n\n
   @dontinclude RigidBodyPlanning.cpp
   Assuming the following namespace definitions:
   @skip ompl::base
   @until ompl::geometric
   And a state validity checking function defined like this:
   @skipline isStateValid
   We first create an instance of the manifold we are planning in.
   @skip plan
   @until StateManifold
   We then set the bounds for the R<sup>3</sup> component of this manifold:
   @skip RealVectorBounds
   @until setBounds
   Create an instance of ompl::base::SpaceInformation for the manifold
   @skipline SpaceInformationPtr
   Set the state validity checker
   @skipline setStateValidityChecker
   Create a random start state:
   @skip start(manifold)
   @until start.random
   And a random goal state:
   @skip goal(manifold)
   @until goal.random
   Create an instance of ompl::base::ProblemDefinition
   @skipline ProblemDefinitionPtr
   Set the start and goal states for the problem definition.
   @skipline setStartAndGoalStates
   Create an instance of a planner
   @skipline PlannerPtr
   Tell the planner which problem we are interested in solving
   @skipline setProblemDefinition
   Make sure all the settings for the space and planner are in order. This will also lead to the runtime computation of the state validity checking resolution.
   @skipline planner->setup
   We can now try to solve the problem. This call returns a boolean flag indicating whether 
   a solution has been found within the specified amount of time (in seconds).
   @skipline bool solved
   If a solution has been found, we display it. Simplification could be done, but we would need to create an instance of ompl::geometric::PathSimplifier.
   @skip solved
   @until }
   \n

@section howto How To's

   \li @ref implementStateManifold 
   \li @ref stateAlloc
   \li @ref stateOps

\author Ioan A. Șucan

*/
