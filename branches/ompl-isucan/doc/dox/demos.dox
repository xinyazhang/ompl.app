
/**
   @page demos Demos

   @subsection gplanRigidBody Geometric planning for a rigid body in 3D

   \li Using ompl::geometric::SimpleSetup :\n\n
   @dontinclude RigidBodyPlanning.cpp
   Assuming the following namespace definitions:
   @skip ompl::base
   @until ompl::geometric
   And a state validity checking function defined like this:
   @skipline isStateValid
   We first create an instance of the manifold we are planning in.
   @skip planWithSimpleSetup
   @until StateManifold
   We then set the bounds for the R<sup>3</sup> component of this manifold:
   @skip RealVectorBounds
   @until setBounds
   Create an instance of ompl::geometric::SimpleSetup. Instances of ompl::base::SpaceInformation,
   and ompl::base::ProblemDefinition are created internally.
   @skipline SimpleSetup
   Set the state validity checker
   @skipline setStateValidityChecker
   Create a random start state:
   @skip start(manifold)
   @until start.random
   And a random goal state:
   @skip goal(manifold)
   @until goal.random
   Set these states as start and goal for SimpleSetup.
   @skipline setStartAndGoalStates
   We can now try to solve the problem. This will also trigger a call to ompl::geometric::SimpleSetup::setup() and create a default instance of a planner,
   since we have not specified one. Furthermore, ompl::base::Planner::setup() is called, which in turn calls ompl::base::SpaceInformation::setup(). This chain
   of calls will lead to computation of runtime parameters such as the state validity checking resolution. This call returns a boolean flag indicating whether 
   a solution has been found within the specified amount of time (in seconds).
   @skipline bool solved
   If a solution has been found, we can optionally simplify it and the display it
   @skip solved
   @until }
   \n

   \li
   Without ompl::geometric::SimpleSetup :\n\n
   @dontinclude RigidBodyPlanning.cpp
   Assuming the following namespace definitions:
   @skip ompl::base
   @until ompl::geometric
   And a state validity checking function defined like this:
   @skipline isStateValid
   We first create an instance of the manifold we are planning in.
   @skip plan
   @until StateManifold
   We then set the bounds for the R<sup>3</sup> component of this manifold:
   @skip RealVectorBounds
   @until setBounds
   Create an instance of ompl::base::SpaceInformation for the manifold
   @skipline SpaceInformationPtr
   Set the state validity checker
   @skipline setStateValidityChecker
   Create a random start state:
   @skip start(manifold)
   @until start.random
   And a random goal state:
   @skip goal(manifold)
   @until goal.random
   Create an instance of ompl::base::ProblemDefinition
   @skipline ProblemDefinitionPtr
   Set the start and goal states for the problem definition.
   @skipline setStartAndGoalStates
   Create an instance of a planner
   @skipline PlannerPtr
   Tell the planner which problem we are interested in solving
   @skipline setProblemDefinition
   Make sure all the settings for the space and planner are in order. This will also lead to the runtime computation of the state validity checking resolution.
   @skipline planner->setup
   We can now try to solve the problem. This call returns a boolean flag indicating whether 
   a solution has been found within the specified amount of time (in seconds).
   @skipline bool solved
   If a solution has been found, we display it. Simplification could be done, but we would need to create an instance of ompl::geometric::PathSimplifier.
   @skip solved
   @until }
   \n
*/
