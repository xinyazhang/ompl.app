/**
\page gui Graphical User Interface to OMPL

\par Contents:
- \ref gui_define
- \ref gui_planners
- \ref gui_bounding_box
- \ref gui_paths

\section gui_define Defining a motion planning problem

\htmlonly<img src="../images/gui_define.png" class="span-15 nofloat">\endhtmlonly

The OMPL.app GUI is launched from the command line with the \c omplapp/app/ompl_app.py command. After the program launches, select <i>File>Open Environment</i> to read a file that contains a mesh for an environment. After the environment is loaded, select <i>File>Open Robot</i> to choose a robot mesh file. Example environment and robot files can be found in \c omplapp/resources. At this point the GUI can only be used to solve motion planning problems involving static environments and free-flying rigid bodies in 3D, but this is likely to change in a future version of OMPL. After the meshes are loaded, you can specify the start and goal poses of the robot with the controls on the righthand side of the window. The image above shows an example query for the cubicles environment. 

\section gui_planners Setting up the planner

\htmlonly<img src="../images/gui_planner.png" class="span-15 nofloat">\endhtmlonly

It is not strictly necessary to choose or configure a planner; if you don't, a planner will automatically be chosen and configured for you. The planner tab allows you to override the default settings, and experiment with different planners. Each planner has different parameters that control its behavior. When you select a different planner, the appropriate options are shown. Below is a list of all parameters:
- <b>Range:</b> This parameter represents the maximum length of a
motion to be added in the tree of motions. It greatly influences the runtime of the
algorithm.
- <b>Goal bias:</b> In the process of randomly selecting states in the state space to attempt to go towards, the algorithm may in fact choose the actual goal state with some probability. This probability is a real number between 0.0 and 1.0; its value should usually be around 0.05 and should not be too large. It is probably a good idea to use the default value.
- <b>Border fraction:</b> The fraction of time for focusing exploration on the border cells (cells at the exploration “frontier”). This is the minimum percentage used to select cells that are exterior (minimum because if 95% of cells are on the border, they will be selected with 95% chance, even if this percentage is set to 90%).
- <b>Max. nearest neighbors:</b> The maximum number of nearest neighbors for which a connection will be attempted when a new configuration sample is added.
.
In addition to these planning parameters, you can set a time limit for the planning algorithm to solve a motion planning problem and the collision checking resolution. When the environment and robot meshes are read, a collision checking resolution is chosen based on the shortest edge length occurring in both meshes, but this setting can be overridden.


\section gui_bounding_box Defining a bounding box for the robot

By default, the robot is constrained to move inside a tight bounding box around the environment, the start pose, and the goal pose. This bounding box applies to a <b>reference point</b> for the robot; the origin of the coordinate frame that defines its pose. This means that parts of the robot can stick outside the bounding box. It also means that if the reference point for your robot is far away from the robot itself, you can get rather unintuitive results.

\htmlonly<img src="../images/gui_bbox.png" class="span-15 nofloat">\endhtmlonly

If you move the start or goal pose outside the bounding box, the bounding box will automatically grow. You can adjust the automatic settings in the "Bounding box" tab, as shown above.

\section gui_paths Visualizing solution paths

\htmlonly<img src="../images/gui_path.png" class="span-15 nofloat">\endhtmlonly

After you have specified a motion planning, you can click on the \b Solve button to run the motion planner. Some diagnostic information is printed in the terminal window, which can be helpful in identifying problems. If all goes well, the planner finds a path. By default, OMPL.app will loop over an animation of the robot's pose along the path. The slider at the bottom of the window controls the speed of the animation. By unchecking the \b Animate checkbox, the entire path is shown at once (see figure above). Pressing the \b Clear button removes the solution path. It is possible to save the path with <i>File>Save Path</i>, so that it can be “played back” at a later time. Paths can be opened via the <i>File>Open Path</i> dialog. Paths do not necessarily need to produced by OMPL.app, but can be produced by, e.g., a command line program as well. However, only geometric paths consisting of SE(3) states can be loaded. The format of a path file is extremely simple. It consists of a sequence of states in this format:
\code
Compound state [
RealVectorState [7.20776 3.36397 90.5368]
SO3State [0.034124 -0.0591456 -0.0406794 0.996836]
]
\endcode
In your own programs you can simply use the \c PathGeometric::print method in C++ and the built-in \c print function in python to “print” a path to an output file.


*/
