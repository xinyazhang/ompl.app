import argparse
from six.moves import configparser
import numpy as np
from scipy.io import savemat,loadmat
import sys
import os
from os.path import abspath, dirname, join

sys.path.insert(0, './lib') # FIXME: a more portable solution
import pyse3ompl as plan

def read_xyz(config, section, prefix):
    ret = np.zeros(shape=(3), dtype=np.float64)
    for i,suffix in enumerate(['x','y','z']):
        ret[i] = config.getfloat(section, prefix + '.' + suffix)
    return ret

def _create_driver(args):
    puzzle_dir = dirname(args.puzzle)
    config = configparser.ConfigParser()
    config.read([args.puzzle])
    env_fn = join(puzzle_dir, config.get("problem", "world"))
    rob_fn = join(puzzle_dir, config.get("problem", "robot"))
    driver = plan.OmplDriver()
    driver.set_planner(args.planner, args.sampler, args.saminj, args.rdt_k)
    driver.set_model_file(plan.MODEL_PART_ENV, env_fn)
    driver.set_model_file(plan.MODEL_PART_ROB, rob_fn)
    for i,prefix in zip([plan.INIT_STATE, plan.GOAL_STATE], ['start', 'goal']):
        tr = read_xyz(config, 'problem', prefix)
        rot_axis = read_xyz(config, 'problem', prefix + '.axis')
        rot_angle  = config.getfloat('problem', prefix + '.theta')
        driver.set_state(i, tr, rot_axis, rot_angle)
    lo = read_xyz(config, 'problem', 'volume.min')
    hi = read_xyz(config, 'problem', 'volume.max')
    driver.set_bb(lo, hi)
    driver.set_cdres(args.cdres)

    return driver

def _load_states_from_dic(dic):
    if 'file' not in dic:
        return None, 0, 0, None
    is_fn = dic['file']
    is_key = dic['key'] if 'key' in dic else None
    is_offset = int(dic['offset'])
    is_size = int(dic['size']) if 'size' in dic else 1
    is_out = dic['out']
    d = np.load(is_fn)
    if is_key is None:
        is_key = list(d.keys())[0]
    A = d[is_key]
    total_size = A.shape[0]
    if is_size == -1:
        is_size = total_size
    return A, is_size, is_offset, is_out

def solve(args):
    driver = _create_driver(args)
    if args.replace_istate is not None or args.replace_gstate is not None:
        A, is_size, is_offset, is_out = _load_states_from_dic(args.istate_dic)
        B, gs_size, gs_offset, gs_out = _load_states_from_dic(args.gstate_dic)
        # FIXME: better error handling for input
        assert is_size == gs_size or is_size == 0 or gs_size == 0
        if is_size == 0:
            out_dir = gs_out
        else:
            out_dir = is_out
        for i in range(max(is_size,gs_size)):
            index = is_offset + i
            gindex = gs_offset + i
            if is_size > 0:
                if index > A.shape[0]:
                    break
                driver.substitute_state(plan.INIT_STATE, A[index])
            if gs_size > 0:
                if gindex > B.shape[0]:
                    break
                driver.substitute_state(plan.GOAL_STATE, B[gindex])
            V,E = driver.solve(args.days, return_ve = True)
            savemat('{}/tree-{}.mat'.format(out_dir, index), dict(V=V, E=E))
    else:
        driver.solve(args.days, args.out)

def merge_forest(args):
    # Create PRM planner
    args.planner = plan.PLANNER_PRM
    args.sampler = 0 # Uniform sampler
    args.saminj = ''
    args.rdt_k = 0
    driver = _create_driver(args)
    def matgen(paths):
        for p in paths:
            if os.path.isfile(p):
                yield p
            else:
                for fn in os.listdir(p):
                    if fn.endswith('.mat'):
                        yield join(p, fn)
    for fn in matgen(args.trees):
        d = loadmat(fn)
        driver.add_existing_graph(d['V'], d['E'])
    V,E = driver.solve(args.days, return_ve = True)
    if args.out is not None:
        savemat(args.out, dict(V=V, E=E))

def main():
    main_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    subparsers = main_parser.add_subparsers(dest='command')
    parser = subparsers.add_parser("solve", help='Solve a puzzle with the specified planner.')
    parser.add_argument('puzzle', help='Configure file generated by OMPL GUI')
    parser.add_argument('planner', help='Choose a planner', choices=range(18), type=int)
    parser.add_argument('days', help='Time limit in day(s)', type=float)
    parser.add_argument('--out', help='Output complete planning data', default='')
    parser.add_argument('--sampler', help='Valid state sampler', type=int, default=0)
    parser.add_argument('--saminj', help='Sample injection file', type=str, default='')
    parser.add_argument('--rdt_k', help='K Nearest in RDT algorithm', type=int, default=1)
    parser.add_argument('--cdres', help='Collision detection resolution', type=float, default=0.005)
    parser.add_argument('--replace_istate', help='''
Replace Initial State. Syntax: file=<path to npz>,key=<npz key>,offset=<number>,size=<number>,out=<dir>,
in which key=, size= are optional.
key is default to the first array in NPZ,
and size is default to 1''',
            type=str, default=None)
    parser.add_argument('--replace_gstate', help='''Same syntax with replace_istate, but replaces goal state''', type=str, default=None)
    parser = subparsers.add_parser("merge_forest", help='Merge the planning data from multiple planners')
    parser.add_argument('puzzle', help='Configure file generated by OMPL GUI')
    parser.add_argument('days', help='Time limit in day(s)', type=float)
    parser.add_argument('trees', help='''Tree/Graph files/directories created by individual planner.
If a directory is provided, all .mat files in this directory will be loaded''', nargs='+')
    parser.add_argument('--out', help='Output file of the merged graph, in .npz format', default=None)
    parser.add_argument('--cdres', help='Collision detection resolution', type=float, default=0.005)
    args = main_parser.parse_args()
    if hasattr(args, 'replace_istate') and args.replace_istate is not None:
        dic = dict(item.split("=") for item in args.replace_istate.split(","))
        print(dic)
        assert ('file' in dic) and ('offset' in dic) and ('out' in dic), '--replace_istate need file, offset and out'
        if 'size' in dic and int(dic['size']) > 1:
            assert 'out' in dic, 'size= requires out= for storage'
        args.istate_dic = dic
    if hasattr(args, 'replace_gstate') and args.replace_gstate is not None:
        dic = dict(item.split("=") for item in args.replace_gstate.split(","))
        print(dic)
        assert ('file' in dic) and ('offset' in dic) and ('out' in dic), '--replace_gstate need file, offset and out'
        if 'size' in dic and int(dic['size']) > 1:
            assert 'out' in dic, 'size= requires out= for storage'
        args.gstate_dic = dic

    globals()[args.command](args)

if __name__ == '__main__':
    main()
